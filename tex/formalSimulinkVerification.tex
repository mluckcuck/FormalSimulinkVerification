\section{Formal Verification of Simulink Models}
\label{sec:formalSimulinkVerification}

This section discusses some of the main approaches used in the literature to formally verify or model Simulink diagrams. The literature is organised by the main formal approach used.

The literature is summarised in Section~\ref{sec:litSum}.

\subsection{Theorem Proving and SMT Solving}
\label{sec:tp}

In Araiza-Illan et al. 2014~\cite{araiza-illan_formal_2014}, assertion blocks are added to Simulink models to describe the properties (over the Simulink signals) that the system should preserve. These assertions take the form of a \texttt{require} block, which is used to describe a Hoare triple: $\{precondition\} model \{postondition\}$. A \texttt{require} block is constructed from an \texttt{Enabled Subsystem}, which conditionally executes when a control signal (the precondition) is positive and itself contains an \texttt{Assert} block. Once this specification is added to the Simulink diagram, they provide an automatic translation into the input language of the Why3\footnote{Why3: \url{http://why3.lri.fr/}} theorem proving platform, and used CVC3\footnote{CVC3: \url{https://cs.nyu.edu/acsys/cvc3/}} to verify the Simulink diagram against the properties described by the assertion blocks. Their translation strategy works on Simulink signals that are scalar and discrete, but they aimed to extend the approach to continuous time. 

In Bernardeschi et al. 2018~\cite{bernardeschi_pvs-simulink_2018} describe a parallel combination of the theorem prover PVS\footnote{PVS: \url{http://pvs.csl.sri.com/} } and Simulink models, to analyse Cyber-Physical Systems\footnote{Cyber-Physical Systems are those where a computer system controls a mechanism that operates in and effects the `real-world'.}. The PVS model captures the discrete semantics of the system and the Simulink model captures the continuous dynamics of the system's environment. Their example system is a pacemaker. Their approach centres around co-simulation. They use PVSio-Web\footnote{PVSio-Web: \url{http://www.pvsioweb.org/}}, which is a Web framework that enables formal-model-based development of Human-Machine Interfaces, to connect the PVS model to the Simulink diagram. They also use an additional block in the Simulink diagram to extract the simulation data. PVSio-Web uses this block's output to keep the PVS model in-sync with the Simulink simulation.

In Liebrenz et al. 2018~\cite{liebrenz_deductive_2018}, Simulink diagrams are automatically translated to \gls{dl} to enable interactive theorem proving using KeYmaera X\footnote{KeYMaera X: \url{https://www.keymaerax.org/index.html} }. Their approach can capture both discrete- and continuous-time elements of Simulink diagrams, because their target language is \gls{dl}. However, their automatic translation assumes: no algebraic loops, no S Function blocks\footnote{S (System) Function blocks wrap a program, written in either: MATLAB, C C++, or FORTRAN code}, and no external scripts or libraries. Their approach is implemented in the MeMo Framework\footnote{Which I can't find a link for} and demonstrated on a temperature control system, where they verify that the system keeps with the given temperature range and does not rapidly switch on and off.

In Reicherdt and Glensner 2014~\cite{reicherdt_formal_2014} discrete-time Simulink diagrams are translated into Boogie, an intermediate language for the Boogie verification framework\footnote{Boogie: \url{https://www.microsoft.com/en-us/research/project/boogie-an-intermediate-verification-language/?from=http\%3A\%2F\%2Fresearch.microsoft.com\%2Fen-us\%2Fprojects\%2Fboogie\%2F}}. This approach is implemented in the MeMo Framework, like \cite{liebrenz_deductive_2018}. The automatic translation supports 44 basic blocks and assumes: only discrete and stateless blocks, every block has a fixed sample time, no S Function blocks or Stateflow charts, no bus-capable blocks or composite data types\footnote{bus-capable blocks accept composite signals, which are multiple signals combined to easier reading of the diagram}. Also, various blocks, like lookup tables, signal builders, or blocks with arithmetic that Boogie doesn't support are over-approximated. They demonstrate their approach on four models of automotive systems: a turn indicator, an odometer, and two versions of a distance warning system. They compared their approach to the Simulink Design Verifier, which timed out when attempting to verify one model, whereas their tool took a little under two minutes on the same model.

Huang and Kang 2019~\cite{huang_formal_2019} describe algorithms for modelling Simulink-based states\footnote{Simulink-based state seems to be a Simulink model inside a state node in a Stateflow diagram (MATLAB's own \gls{fsm} notation).} as \gls{gha} and uses the dReal solver\footnote{dReal: \url{https://dreal.github.io/}} for verification of timing behaviour. Their translation appears to be manual, and is demonstrated on an uncrewed boat. The boat's control system has four requirements, that: it arrives at its destination within a given time limit, course corrections should occur within a given time limit, the GPS should capture the boat's position with a given period, and the accelerometer should check the boat's speed with a given period. These requirements were modelled as SMT conditions and checked using dReal, which took between 49.30 and 415.68 minutes. 

In Herber et al. 2013~\cite{herber_bit-precise_2013} present an automatic translation from (discrete-time) Simulink models to the input language of the UCLID system verification toolkit\footnote{UCLID: \url{https://github.com/uclid-org/uclid}}. Their translation approach supports only discrete-time Simulink blocks and assumes that: the sample time is fixed for each block, no Iterator blocks, no external code is used. Further, they only support Boolean, fixed bit-width integers, and fixed-point data types; they over-approximate lookup tables, only translate vector and scalar signals, and cannot cope with Sateflow or S Function blocks. They integrate their approach into the MeMo Framework, like \cite{reicherdt_formal_2014} and \cite{liebrenz_deductive_2018}. They demonstrate their approach on an automotive multi-object distance control system. Its simulink diagram has 263 blocks and 364 signal lines. They check that no variable or signal can over or underflow. They compared their approach to the Simulink Design Verifier, which timedout ``in all cases''. 

\section{Model Checking}
\label{sec:modelChecking}

Meenakshi et al.~\cite{meenakshi_tool_2006} present a tool that automatically translates (certain) Simulink diagrams into the input language of the model checker NuSMV\footnote{NuSMV: \url{https://nusmv.fbk.eu/index.html}}. Their tool parses information about the Simulink diagram from its textual representation in an \texttt{mdl} file, then translates it for NuSMV. The translation is restricted to discrete Simulink diagrams only, due to NuSMV only catering for discrete models. Their tool can also reverse the translation, to aid with debugging the Simulink diagram from counterexamples. 

\subsection{Automata Representations}

In Zhou and Kumar~\cite{zhou_semantic_2012} present algorithms to translate (a class of) Simulink diagrams to \gls{ioefa}. Each Simulink block is modelled by a combination of an \gls{ioefa} for its output-assignments and an \gls{ioefa} for state-updates. They state that their approach has ``no specific restriction on the types of Simulink blocks or the structure of Simulink diagrams supported and can handle multirate Simulink diagrams, sample times with initial offsets and variable-step simulation etc." However, the paper only presents algorithms for the translation, there is no tool support mentioned.

Agrawal et al. 2004~\cite{agrawal_semantic_2004} present a translation from a Simulink/Stateflow diagram into a Hybrid Automata. Their approach uses the Graph Rewriting and Transformation (GReAT) language/tool\footnote{GReAT: \url{https://www.isis.vanderbilt.edu/tools/GReAT}} to translate the diagrams in the XML-based Hybrid System Interchange Format. They support a restricted subset of the primitie Simulink blocks. They demonstrate their translation on a (water) tank control system, but do not seem to present any verification facilitated by the resulting Hybrid Automata model.
